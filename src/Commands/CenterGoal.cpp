// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "CenterGoal.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

CenterGoal::CenterGoal(float width, float centerX, /*float centerY,*/ float widthTolerance=0.1, float centerXTolerance=0.1/*, float centerYTolerance=0.1*/): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(chassis);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

	m_width = width;
	m_centerX = centerX;
//	m_centerY = centerY;

	m_widthTolerance = widthTolerance;
	m_centerXTolerance = centerXTolerance;
//	m_centerYTolerance = centerYTolerance;

	aligned = false;
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void CenterGoal::Initialize() {

}

// Called repeatedly when this Command is scheduled to run
void CenterGoal::Execute() {
	std::vector<double> values = Robot::networkTable->GetNumberArray("width", llvm::ArrayRef<double>());
	float currentWidth = values[0];
	if (IsCorrectWidth(currentWidth)) {
//		values = Robot::networkTable->GetNumberArray("centerY", llvm::ArrayRef<double>());
//		float currentY = values[0];
//		if (IsCorrectY(currentY)) {
			values = Robot::networkTable->GetNumberArray("centerX", llvm::ArrayRef<double>());
			float currentX = values[0];
			if (IsCorrectX(currentX)) {
				aligned = true;
			}
			else {
				AlignX(currentX);
			}
//		}
//		else
//			AlignY(currentY);
	}
	else
		AlignWidth(currentWidth);
}

bool CenterGoal::IsCorrectWidth(float currentWidth) {
	return abs(m_width - currentWidth) < m_widthTolerance;
}

void CenterGoal::AlignWidth(float currentWidth) {
	if (currentWidth > m_width) {
		Robot::driving->driveTank(0.3,0.3);
	}
	else {
		Robot::driving->driveTank(-0.3,0.3);
	}
}

//bool CenterGoal::IsCorrectY(float currentY) {
//	return abs(m_centerY - currentY) < m_centerYTolerance;
//}

//void CenterGoal::AlignY(float currentY) {
//	if (currentY > m_centerY) {
//		Robot::driving->driveTank(0.3,0.3);
//	}
//	else {
//		Robot::driving->driveTank(-0.3,0.3);
//	}
//}

bool CenterGoal::IsCorrectX(float currentX) {
	return abs(m_centerX - currentX) < m_centerXTolerance;
}

void CenterGoal::AlignX(float currentX) {
	if (currentX > m_centerX) {
		Robot::driving->driveTank(0.3,-0.3);
	}
	else {
		Robot::driving->driveTank(0.3,0.3);
	}
}


// Make this return true when this Command no longer needs to run execute()
bool CenterGoal::IsFinished() {
    return aligned;
}

// Called once after isFinished returns true
void CenterGoal::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void CenterGoal::Interrupted() {

}
