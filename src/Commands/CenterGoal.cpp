// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "CenterGoal.h"

#define DRIVE_ALIGNMENT_SPEED 0.5
#define ROTATE_SPEED 0.6
#define TARGET_TIME 5

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

CenterGoal::CenterGoal(float width, float centerX, /*float centerY,*/ float widthTolerance, float centerXTolerance/*, float centerYTolerance=0.1*/): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(chassis);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

	Requires(Robot::driving.get());
	printf("Center goal init\n");
	m_width = width;
	m_centerX = centerX;
//	m_centerY = centerY;

	m_widthTolerance = widthTolerance;
	m_centerXTolerance = centerXTolerance;
//	m_centerYTolerance = centerYTolerance;

	aligned = false;

	onTargetTimer = new Timer();
	t = new Timer();
	prevT = 0;
	currentT = 0;
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void CenterGoal::Initialize() {
	aligned = false;
	onTargetTimer->Reset();
	onTargetTimer->Start();
	t->Start();
}

// Called repeatedly when this Command is scheduled to run
void CenterGoal::Execute() {
	std::vector<double> values = Robot::networkTable->GetNumberArray("myContoursReport/width", llvm::ArrayRef<double>());

	if (values.size() > 0) {
		float currentWidth = values[0];
		values = Robot::networkTable->GetNumberArray("myContoursReport/centerX", llvm::ArrayRef<double>());
		float currentX = values[0];
		if (IsCorrectX(currentX)) {
			if (IsCorrectWidth(currentWidth)) {
				printf("Aligned");
				aligned = true;
				return;
			}
			else {
				AlignWidth(currentWidth);
			}
		}
		else {
			AlignX(currentX);
		}
	}
	else {
		printf("Empty network table\n");
	}


	currentT = t->Get();
	SmartDashboard::PutNumber("Time", currentT - prevT);
	prevT = currentT;
	onTargetTimer->Reset();
	aligned = false;

//	if (IsCorrectWidth(currentWidth)) {
//		printf("At correct width\n");
////		values = Robot::networkTable->GetNumberArray("centerY", llvm::ArrayRef<double>());
////		float currentY = values[0];
////		if (IsCorrectY(currentY)) {
//
//			if (IsCorrectX(currentX)) {
//				printf("Aligned\n");
//				aligned = true;
////				onTargetTimer->Start();
//			}
//			else {
//				printf("Should align x\n");
//				AlignX(currentX);
//				onTargetTimer->Reset();
//			}
////		}
////		else
////			AlignY(currentY);
//	}
//	else {
//		printf("Should align width\n");
//		AlignWidth(currentWidth);
//		onTargetTimer->Reset();
//	}
//	}
//	else {
//		printf("Network table empty\n");
//		onTargetTimer->Reset();
//	}
//	}
//	catch (std::exception* e) {
//		printf("Exception: %s", e->what());
//	}

}

bool CenterGoal::IsCorrectWidth(float currentWidth) {
	return abs(m_width - currentWidth) < m_widthTolerance;
}

void CenterGoal::AlignWidth(float currentWidth) {
	printf("Aligning width\n");
	if (currentWidth > m_width) {
		Robot::driving->driveTank(DRIVE_ALIGNMENT_SPEED,DRIVE_ALIGNMENT_SPEED);
	}
	else {
		Robot::driving->driveTank(-DRIVE_ALIGNMENT_SPEED,-DRIVE_ALIGNMENT_SPEED);
	}
}

//bool CenterGoal::IsCorrectY(float currentY) {
//	return abs(m_centerY - currentY) < m_centerYTolerance;
//}

//void CenterGoal::AlignY(float currentY) {
//	if (currentY > m_centerY) {
//		Robot::driving->driveTank(0.3,0.3);
//	}
//	else {
//		Robot::driving->driveTank(-0.3,0.3);
//	}
//}

bool CenterGoal::IsCorrectX(float currentX) {
	return abs(m_centerX - currentX) < m_centerXTolerance;
}

void CenterGoal::AlignX(float currentX) {
	printf("Rotating\n");
	if (currentX > m_centerX) {
		printf("Rotating left\n");
		Robot::driving->driveTank(-ROTATE_SPEED,ROTATE_SPEED);
	}
	else {
		Robot::driving->driveTank(ROTATE_SPEED,-ROTATE_SPEED);
	}
}


// Make this return true when this Command no longer needs to run execute()
bool CenterGoal::IsFinished() {
    return aligned && onTargetTimer->Get() > TARGET_TIME;
}

// Called once after isFinished returns true
void CenterGoal::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void CenterGoal::Interrupted() {

}
